## BackGround

现在的服务基本是分布式，微服务形式的，而且大数据量也导致分库分表的产生，对于水平分表就需要保证表中 id 的全局唯一性。

对于 MySQL 而言，一个表中的主键 id 一般使用自增的方式，但是如果进行水平分表之后，多个表中会生成重复的 id 值。那么如何保证水平分表后的多张表中的 id 是全局唯一性的呢？

如果还是借助数据库主键自增的形式，那么可以让不同表初始化一个不同的初始值，然后按指定的步长进行自增。例如有3张拆分表，初始主键值为1，2，3，自增步长为3。

当然也有人使用 UUID 来作为主键，但是 UUID 生成的是一个无序的字符串，对于 MySQL 推荐使用增长的数值类型值作为主键来说不适合。

也可以使用 Redis 的自增原子性来生成唯一 id，但是这种方式业内比较少用。

当然还有其他解决方案，不同互联网公司也有自己内部的实现方案。雪花算法是其中一个用于解决分布式 id 的高效方案，也是许多互联网公司在推荐使用的。



## SnowFlake 雪花算法

**SnowFlake** 中文意思为雪花，故称为雪花算法。最早是 **Twitter** 公司在其内部用于分布式环境下生成唯一 ID。在2014年开源 **scala** 语言版本。

![](https://cdn.jsdelivr.net/gh/RivTian/Blogimg/img/202302172241747.png)

雪花算法原理就是生成一个的64位比特位的 long 类型的唯一 id。

- 最高1位固定值0，因为生成的 id 是正整数，如果是1就是负数了。
- 接下来41位存储毫秒级时间戳，2^41/(1000\*60\*60\*24\*365)=69，大概可以使用69年。
- 再接下10位存储机器码，包括5位 **datacenterId** 和5位 workerId。最多可以部署2^10=1024台机器。
- 最后12位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成2^12=4096个不重复 id。

可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。

对于每一个雪花算法服务，需要先指定10位的机器码，这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的10位比特位的整数值都行。